[{"categories":["develope"],"contents":"在iOS開發中，幾乎所有頁面都會使用Autolayout的方式去排版，而在設定完LayoutConstraints後，有時會在Runtime出現一些Error log，雖然不一定會影響顯示出來的排版，但有報錯基本上就要修正。\nError Log [LayoutConstraints] Unable to simultaneously satisfy constraints. Probably at least one of the constraints in the following list is one you don\u0026#39;t want. Try this: (1) look at each constraint and try to figure out which you don\u0026#39;t expect; (2) find the code that added the unwanted constraint or constraints and fix it. ( \u0026#34;\u0026lt;MASLayoutConstraint:0x600000393660 UIButton:0x7fe97b466f20.right == UIView:0x7fe97b458ba0.right - 20\u0026gt;\u0026#34;, \u0026#34;\u0026lt;NSLayoutConstraint:0x6000004f1a90 UIImageView:0x7fe97b4671d0.leading == UIButton:0x7fe97b466f20.trailing + 8\u0026gt;\u0026#34;, \u0026#34;\u0026lt;NSLayoutConstraint:0x6000004f1540 UIView:0x7fe97b458ba0.trailing == UIImageView:0x7fe97b4671d0.trailing + 20\u0026gt;\u0026#34; ) Will attempt to recover by breaking constraint \u0026lt;NSLayoutConstraint:0x600001baebc0 UIImageView:0x7fe97b4671d0.leading == UIButton:0x7fe97b466f20.trailing + 8\u0026gt; Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger. The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in \u0026lt;UIKitCore/UIView.h\u0026gt; may also be helpful. 什麼情況會出現這個錯誤？ 一般來說，出現這種警告有兩種情況：\n 使用xib的內建View，對其中子元件增加了Autolayout約束，在使用xib後又調整了View的框架 純Code的方式使用Autolayout，但沒有對使用的ViewAutoresizingMaskIntoConstraints的屬性設置為false。  如何快速找出有問題的元件？ 其實在Error log中有給出很明錯錯誤的地方，那就是在log中Will attempt to recover by breaking constraint的下一行，就是我們要尋找的約束。\n// 關鍵線索 Will attempt to recover by breaking constraint \u0026lt;NSLayoutConstraint:0x600001baebc0 UIImageView:0x7fe97b4671d0.leading == UIButton:0x7fe97b466f20.trailing + 8\u0026gt; 但初學者在看到這個錯誤時會特別的頭痛，因為在Error log中通常只會寫出哪個元件的類型，例如：NSLayoutConstraint、UIImageView等等，這樣對於比較複雜的頁面會很難找出錯誤的約束。\nXcode其實提供了一個很方便的Debug功能，可以幫助我們迅速地找到錯誤的約束，而我們要使用的就是Xcode內建的Debug View Hierarchy。\n使用Debug View Hierarchy找出元件 STEP 1： 執行App STEP 2： 點選 Xcode 下方的 Debug View Hierarchy 這時候你會看到整個App所有View的結構，是不是很方便呢\nSTEP 3： 找出錯誤約束的實體位址 還記得剛剛我們有特別找出錯誤的約束嗎？\nWill attempt to recover by breaking constraint // 我們要的就是NSLayoutConstraint的實體位址0x600001baebc0 \u0026lt;NSLayoutConstraint:0x600001baebc0 UIImageView:0x7fe97b4671d0.leading == UIButton:0x7fe97b466f20.trailing + 8\u0026gt; 而我們要找的就是第3行的部分，將NSLayoutConstraint的實體位址0x600001baebc0複製起來。\nSTEP 4： 用實體位址去找出錯誤的約束在哪裡 接著我們去左邊Debug navigator搜尋，並以剛剛的0x600001baebc0過濾元件，這時候就可以很快速的找到出錯的約束了。\n總結 以前在初學的時候，遇到這個問題總是很頭痛，有一種大海撈針的感覺。\n而現在透過Xcdoe內建的Debug View Hierarchy就可以很快速的找到特定的元件，有時也可以查看UI元件的排版是不是有誤，真的是很方便很多。\n","date":"22","image":null,"permalink":"https://martinhuang0933.github.io/blog/ios-fix-layout-constraints/","tags":["iOS","Xcode","develope"],"title":"【 iOS 】Unable to simultaneously satisfy constraints 約束設定錯誤處理"},{"categories":["develope"],"contents":"什麼是Singleton？ 在許多物件導向設計的程式語言中，單例設計模式非常常見，而他的實際效益就是可以確保在整個應用程式中只會有一個實體，且生命週期也跟應用程式相同，在應用程式啟動時就會自動幫我們建立了。 在iOS開發學習的過程中也許你已經用了許多Singleton的物件了，只是你還不知道而已，例如：UIColor、FileManager等等。\nSingleton 會用在哪些場合？ Singleton因為具有唯一性，所以通常會用於：\n 環境變數、已定義的參數檔案 常用的資料處理算法，如字串轉換、時間轉換、資料庫連接、網路連接等等。  Singleton 怎麼寫？ 建立Singleton最基礎的寫法就是判斷實體是不是為空值，如果是空值就會直接建立。 在建立時需要注意執行緒衝突，所以我們需要多加上執行緒的安全機制，實際程式碼如下。\n// Objective-C 版本 + (instancetype)shareManager{ @synchronized(self){ if (!manager) { manager = [[self alloc]init]; } return manager; } } 也可以透過GCD的方式建立\n// Objective-C 版本 , 使用GCD static DataManager *manager = nil; @implementation DataManager + (instancetype)shareManager{ static dispatch_once_t onceToken; dispatch_once(\u0026amp;onceToken, ^{ manager = [[self alloc] init]; }); return manager; } @end 此時Singleton就已經寫好了，只要我們在外面呼叫shareManager這個方法，返回的實體始終是一個，因為dispatch_once只執行一次。\n// Objective-C 版本 , 呼叫 Singleton { [DataManager shareManager]; } ","date":"21","image":null,"permalink":"https://martinhuang0933.github.io/blog/ios-singleton-design-pattern/","tags":["iOS","Design Pattern","develope"],"title":"【 iOS 】Singleton Design Pattern 單例設計模式"},{"categories":["develope"],"contents":"大家都知道 Xcode 除了是吃效能的怪獸以外，同時也是很會吃儲存空間的開發工具。\n若一開始再購買 mac 時沒有把硬碟空間買好買滿，那未來在開發時很有可能會遇到空間不足的問題。尤其是在 Xcode 改版時，如果要同時兼容新舊版本，那就會是一件非常痛苦的事。\n以下一些清空間的方法，希望可以幫助到還在苦海的各位 (我也曾經在那片海裡QQ)。\n1. Build App caches 用途： 儲存各App Build的結果，並生成索引\n位置： ~/Library/Developer/Xcode/DerivedData\n刪除方法： 直接刪除 DerivedData 內所有檔案即可\n備註： 對於 DerivedData 有興趣的可以看這裡\n2. iOS DeviceSupport 用途： 儲存 iOS 的版本\n位置： ~/Library/Developer/Xcode/iOS DeviceSupport\n刪除方法： 直接刪除iOS版本即可，如14.2 (18B92)\n備註： 以實機開發時，每一台設備的版本被都會儲存起來，如果你用許多不同的iOS的版本在測試，那使用空間就會很可觀\n3. Simulator devices 用途： 模擬器版本\n位置： ~/Library/Developer/CoreSimulator/Devices\n刪除方法： 至終端機下指令xcrun simctl delete unavailable\n4. Archives \u0026amp; .ipa file 用途： 每次打包專案時都會產生，用來提交 App Store 或是TestFlight 等等\n位置： ~/Library/Developer/Xcode/Archives\n刪除方法： 直接刪除即可\n備註： 若為已上線之產品，建議預留最後3-5個的版本\n5. Logs 用途： 就，Log\n位置： ~/Library/Developer/Xcode/iOS Device Logs\n刪除方法： 直接刪除 iOS Device Logs 內所有檔案即可\n6. Others cache 用途： 整個資源庫的快取\n位置： ~/Library/Caches/\n刪除方法： 直接刪除 Caches 內所有檔案即可\n備註： 若不放心，可以將資料夾移到桌面，再重啟電腦看有沒有異狀。\n 工具推薦： App DevCleaner for Xcode\n非常實用的工具，可以快速清除 DeviceSupport、DerivedData、Archives 等等快取檔案。 詳細的使用方法可以參考彼得潘的教學\n總結： 雖然這些肥大的檔案總是讓我們恨得牙癢癢，但不得不說這些檔案確實在編譯階段幫我們省下了不少時間，也是一種用空間換時間的概念。\n剛好遇到問題所以隨筆記錄一下，同時希望這些方法也有幫助到你。\n","date":"21","image":null,"permalink":"https://martinhuang0933.github.io/blog/ios-how-to-clean-xocde/","tags":["iOS","Xcode","develope"],"title":"【 iOS 】如何有效地清理 Xcode"},{"categories":["Manager"],"contents":"近期為求職旺季，很多應屆的畢業生都逐漸的投入職場。\n許多優秀的同學因為沒有入職的經驗，往往不知道第一天會做哪些事情，也不知道要準備些什麼。\n那以產品人自身的經驗來說，除了報到、認識公司環境以外，最重要的就是自我介紹，這是個可以快速建立良好第一印象的機會，為你在職場的人際關係打下基礎。\n教你自我介紹的萬用公式，讓人留下深刻印象：\n我是誰 + 為什麼來這裡 + 我能帶來什麼價值\n📌 我是誰： 這個除了你的姓名以外，可以說一說你有做過哪些事蹟，例如我在大學時事擔任社團社長，或是我對於健身有些研究常指導別人等等。\n這個環節可以透過簡單的背景故事讓大家初步認識你。\n📌 我為什麼來這裡： 如果是入職，可以說因為喜歡公司的哪個部分所以對於公司很有憧憬，同時也想向各位前輩們學習專業知識、領域經驗等。\n如果是參加社交活動，可以說我在哪裡得知這個活動，來這裡是想跟大家交流什麼話題等。\n這個環節也是讓大家初步認識你，可以簡單敘述，但下一點才是比較重要的。\n📌 我能帶來什麼價值： 這一點比較關鍵，如果可以與「我是誰」呼應的話是最好的。\n可以說在某個領域有一些資源，或是自己有哪些專業知識，可以給大家提供交流或是教學。\n不一定是要很專業的技能，例如自己常常會組桌遊團、有很多美食的口袋名單可以分享。\n🔥 舉個例子： 大家好，我是產品人，我的興趣是分享事物，之前在書籍交流社群擔任企劃，有幾次舉辦講座或是分享會的經驗，對商務活動空間或是咖啡廳都有一些不錯的口袋名單，想辦活動或是對咖啡廳有興趣的可以找我，謝謝！\n✨ 這個萬用的自我介紹公式，除了可以用在職場以外，也可以用於很多社交場合。 出社會以後的交友模式跟學生時期會有滿大的不一樣，除了相同興趣、目標以外，如果你有給他人帶來價值的能力，那他人會特別對你感興趣。 有人可能會說這樣交朋友的方式很勢利、很現實，但每一個社會人士其實都很忙，故建立連結也相對困難，但如果你可以給他人帶來價值，這就提供了一個機會讓你們後續可以有更多的交流。 ‼️ 不過有一點要注意的是，幫助他人的同時，也要評估一下是否在自身的能力範圍內，不要因為想幫別人勉強自己。\n","date":"21","image":"images/post/20210721.jpg","permalink":"https://martinhuang0933.github.io/blog/self-introduction-method/","tags":["PM","Office","Introduce"],"title":"【職場】自我介紹很尷尬？萬用公式讓人留下好印象"},{"categories":["Develope"],"contents":"最近在複習 iOS 面試題系列，看到這一題想起幾年前剛接觸 Objective-C ，剛開始觀念還沒有建立起來，也曾經因為這個屬性花了不少時間Debug，雖然現在觀念已經搞懂了，但還是趁這個機會複習筆記一下。\n什麼情況下會有差異？ 你可以先記得，大部分的情況都會使用copy。\n而 copy 與 strong 的差別，在於 copy 是儲存「值」，strong 是儲存「記憶體位址」。\n舉個例子 // .h file @property (strong,nonatomic) NSString *strongStr; @property (copy, nonatomic) NSString *copyStr; // .m file NSMutableString *mutableStr = [NSMutableString stringWithFormat:@\u0026quot;abc\u0026quot;]; // 將mutableStr賦值給retainStr、copyStr self.strongStr = mutableStr; self.copyStr = mutableStr; // 將 mutableStr 更改為 xyz [mutableStr appendString:@\u0026quot;xyz\u0026quot;]; // 印出三個字串的值 NSLog(@\u0026quot;mutableStr = %@\u0026quot;,mutableStr); NSLog(@\u0026quot;strongStr = %@\u0026quot;,self.strongStr); NSLog(@\u0026quot;copyStr = %@\u0026quot;,self.copyStr); // 輸出值 // mutableStr = xyz // strongStr = xyz // copyStr = abc 可以發現，此時 copy 屬性字串並不會因為賦值來源而更改值，反而是strong屬性的字串隨著來源而改變了。\n這是因為 copy 屬性是對於來源做了深拷貝，是將 mutableStr 的數值複製到了 copyStr 上；而 strong 屬性是指向來源的記憶體位址，所以當原本的 mutableStr 改變時，strongStr 也會跟著改變。\n 接著我們在來看一下這三個字串的記憶體位址\n// 印出三個字串的記憶體位址 mutableStr = abcxyz StrStrong = abcxyz StrCopy = abc // 輸出記憶體位址 // mutableStr = 0x6000030ee520 // StrStrong = 0x6000030ee520 // StrCopy = 0xc09e09c05a166394 這時候我們可以看到 mutableStr 與 StrStrong 的記憶體位址是相同的，代表他們兩個儲存值的地方是一樣的，所以才會造成改變 mutableStr 後 StrStrong 也跟著更改的情況。\n小結 比較簡單的記憶法就是 NSString 用 Copy 就好，因為實務上也很少會使用 Strong 屬性的情境。\n雖然現在 Objective-C 比較少人在用了，不過有時候面試還是會考到類似的觀念題，所以邊複習邊整理文章，希望對開發者有些幫助。\n","date":"28","image":null,"permalink":"https://martinhuang0933.github.io/blog/ios-nsstring-copy-or-strong/","tags":["iOS","Swift","Objective-C"],"title":"【 iOS 】NSString 要使用 copy 還是 strong 呢？"},{"categories":["Develope"],"contents":"最近專案接到需求，為了避免程式被反解譯，也避免程式的核心業務邏輯暴露在外，故開始尋找 App 加固的方案。\n資訊安全這門領域其實很深，那既然剛入門我們就從基礎的開始，程式碼混淆在資安方案中算是 CP 值比較高的，開發者混淆時付出一些時間(熟悉以後還可以自動化)，但讓駭客就要多付出好幾倍的時間去破解你的程式，所以在基礎的資安加固方案中會比較推薦程式碼混淆。\n為什麼要做程式碼混淆？ 最近專案接到需求，為了避免程式被反解譯，也避免程式的核心業務邏輯暴露在外，故開始尋找 App 加固的方案。\n資訊安全這門領域其實很深，那既然剛入門我們就從基礎的開始，程式碼混淆在資安方案中算是 CP 值比較高的，開發者混淆時付出一些時間(熟悉以後還可以自動化)，但讓駭客就要多付出好幾倍的時間去破解你的程式，所以在基礎的資安加固方案中會比較推薦程式碼混淆。\n.\n如何做到程式碼混淆？ 市面上有許多的混淆工具，有收費的也有開源的，如果只是想試點水溫會建議用開源的工具玩玩看。但如果專案有時程壓力，可以試試付費的工具，畢竟省時省力 😂。\n這邊我列舉出幾個比較常見的開源混淆工具：\n(1) 「rockbruno/SwiftShield」:  這是我比較推薦的一個，效能不錯、評價高、重點是還有在維護。 手動模式（Objective-C、Swift）：採後綴混淆，簡單易用，缺點是有特定後綴的才會混淆，不適合已開發的專案。 自動模式（Swift）：全局混淆，也可以指定特定資料夾不混淆，缺點是有些語法混淆後會出錯，需要手動修復或是修改原本的程式寫法，但錯誤通常不多。  (2) 「LennonChin/Code-Confuse-Plugin」:  僅混淆 Objective-C 項目(.h.m)，Swift 需指定忽略。 需求為 Python3，以 Define 定義來替換方法名、類別名。  (3) 「onorZhang/iOSConfuse」:  採用前綴的方式進行混淆，一樣不適合已開發的專案。  使用 SwiftShield 進行程式碼混淆 SwiftShield 是一個將 iOS 專案程式碼產製亂數加密名稱的工具，其混淆範圍包含程式碼、Pod 和 Storyboard，可以保護應用程序避免被輕易的反解譯（如 class-dump 和 Cycript）。\n混淆後會是什麼樣子？ class fjiovh4894bvic: XbuinvcxoDHFh3fjid { func cxncjnx8fh83FDJSDd() { return vPAOSNdcbif372hFKF() } } 自動模式（限 Swift 使用） 使用-automatic指令，SwiftShield 將使用 SourceKit 自動混淆整個專案，混淆範圍包含程式碼、Pod 和 Storyboard。\n注意事項 ⚠️  目前有一些 SourceKit Bugs 及不會混淆的類型需注意，如果專案中剛好有遇到特定情境可能需要修改程式碼，詳請請參照本連結。 檔案名稱及資料夾名稱不可包含空白，否則執行混淆時會報錯。 檔案名稱及資料夾名稱若有\u0026quot;-\u0026ldquo;依然會被混淆。  執行步驟  從此處下載最新的 SwiftShield 打開終端機，cd 移動至下載的 Swiftsheild 文件夾下 設置 SwiftShield 的使用權限  # 給予讀、寫、執行的權限 $ sudo chmod -R 777 ./swiftsheild(文件路徑) # 如果使用CocoaPods，需要解鎖權限 $ sudo chmod -R 774 [專案路徑] 官方文件有提到，如果有使用到會修改文件的第三方框架，如：R.Swift、SwiftGen，需在專案中的 TARGETS -\u0026gt; Build Phases -\u0026gt; Run Script 修改指令，這裡以 R.Swift 為範例：  # 原本的 Run Script \u0026quot;$PODS_ROOT/R.swift/rswift\u0026quot; generate \u0026quot;$SRCROOT/[專案名稱]\u0026quot; # 修改後的 Run Script if [ \u0026quot;$SWIFTSHIELDED\u0026quot; != \u0026quot;true\u0026quot; ]; then \u0026quot;$PODS_ROOT/R.swift/rswift\u0026quot; generate \u0026quot;$SRCROOT/[專案名稱]\u0026quot; fi  準備就緒後就可以來下指令進行混淆了，自動模式的指令有以下幾種\n必填參數：\n -automatic：啟用自動模式。 -project-root：專案項目的根目錄。 SwiftShield 會向下搜索你的項目文件。 -automatic-project-file：專案項目的主要.xcodeproj / .xcworkspace文件。 -automatic-project-scheme [myScheme]：專案項目的Scheme。  可選參數：\n -sdk：防止混淆公共類別和方法。如果你正在構建SDK項目，請使用它。 -ignore-modules：防止混淆某些資料夾，並以逗號分隔。如果無法正確混淆某個資料夾，請使用此選項。 要注意的是，是輸入資料夾的確切名稱，而不是目標名稱。例：MyLib,MyAppRichNotifications,MyAppWatch_Extension -show-sourcekit-queries：打印發送到 SourceKit 的查詢。要注意的是這指令會造成非常龐大的輸出，因此只能將其用於錯誤報告和功能開發！  實際組出來以後\n  $ #指令結構 $[SwiftShield 路徑]+空白+\u0026quot;swiftshield\u0026quot;+空白+\u0026quot;-automatic\u0026quot;+空白+\u0026quot;-project-root\u0026quot;+空白+\u0026quot;-automatic-project-file\u0026quot;+空白+[xcworkspace 路徑]+空白+\u0026quot;-automatic-project-scheme\u0026quot;+空白+[專案Target]+空白+\u0026quot;-ignore-modules\u0026quot;+空白+[要忽略的項目(含Pods項目，且需以資料夾名稱為主)] $ #實際執行指令 $ /Users/mac/swiftshield-3.5.1/bin/swiftshield swiftshield -automatic -project-root /Users/mac/[專案資料夾名稱] -automatic-project-file /Users/mac/[專案名稱].xcworkspace -automatic-project-scheme [專案Target] -ignore-modules Alamofire,MJRefresh,SDWebImage...  指令需要執行一小段時間，過程會看到Building project to gather modules and compiler arguments...、Overwriting、Checking等訊息。\n  接著直接打開專案執行看看，通常會出現一點混淆錯誤的Error，基本上都是重複的錯誤，這部分跟程式寫法有關。若不想改動原本程式碼，基本上混淆後再逐一修改即可發布。\n  混淆失敗怎麼辦？ 編譯過程失敗\n 檢查所有檔案名稱或資料夾名稱是否有包含空白。 檢查是否給與正確的權限。 打開下載的 swiftshield 執行檔是否有被 MacOS 安全性阻擋。  混淆後專案執行失敗或 Crash\n 檢查是否有使用到SourceKit Bugs 及不會混淆的類型。 帶 selector 方法的參數中若含有字串，盡量用變量或常量代替  // 修改前 let item1 = UIBarButtonItem(title: \u0026quot;取消\u0026quot;, style: .plain, target: self, action: #selector(cancelButtonClick(sender:))) //混淆後會​​報錯，混淆後會把）}一起混淆進去，導致項目缺少）}而報錯 // 修改後 let cencelTitle = \u0026quot;取消\u0026quot; let item1 = UIBarButtonItem(title: cencelTitle, style: .plain, target: self, action: #selector(cancelButtonClick(sender:))) .xib 文件有可能不會連動到混淆後的類別，要修改File's Owner 若錯誤不多可以手動修復，混淆後會產生 swiftshield-output 資料夾，內有conversionMap.txt，可以對應混淆前後的字串。  對加密的 Crash logs 進行反混淆處理 成功混淆專案後，SwiftShield 將產生一個輸出文件夾，其中包含一個conversionMap.txt 文件，其中包含對該專案所做的所有更改，讓你查明加密對象的前後的字串。\n// // SwiftShield // Conversion Map // Automatic mode for MyApp 2.0 153, 2018-09-24 10.23.48 // Data: ViewController ===\u0026gt; YytSIcFnBAqTAyR AppDelegate ===\u0026gt; uJXJkhVbwdQGNhh SuperImportantClassThatShouldBeHidden ===\u0026gt; GDqKGsHjJsWQzdq 如果你要對混淆後的程式碼文件進行復原，可以透過以下指令復原\n$ swiftshield -deobfuscate CRASH_FILE -deobfuscate-map PATH_TO_CONVERSION_MAP 總結 資訊安全的領域很深，從連線加密、程式碼混淆、LLVM編譯器混淆等等一關接著一關，都是為了保護重要的機密或接口不會被竊取盜用，造成商業損失。\n其實 iOS 系統已經是相對安全的，但對於通訊、金融行業還是要有一定程度的資安保護，畢竟任何資安加固的措施都不能保證百分之百安全，但透過增加駭客反編譯的難度，就能有效降低駭客破解的速度及讓駭客放棄破解打退堂鼓。\nReference  SwiftShield SwiftShield代碼混淆 Swiftshield：SwiftOBJ-C 代碼混淆工具  另外我在搜尋資料時也意外發現有幾篇文章不錯，也分享跟大家。\n 資訊安全從連線加密入手  ","date":"09","image":"https://i.imgur.com/Xa73TNl.png","permalink":"https://martinhuang0933.github.io/blog/ios-information-security-swiftshield/","tags":["iOS","Swift","Security"],"title":"【 iOS 】資訊安全加固方案 - 程式碼混淆(SwiftShield)"}]