{"pages":[],"posts":[{"title":" Protocol buffers 使用教學","text":"Protocol Buffer 是 2008 年由 Google 開發的一種跨平台、跨語言的數據交換格式，是一種將結構化資料序列化（變成二進位制）的方法，Google 提供了多種程式語言的實作方式，每一種實作都包含了相對應語言的編譯器以及 Library。 你可以把它想成另一種形式的 JSON ，但資料要比 JSON 格式更小、傳輸更快，所以用於資料傳輸、資料儲存上面會比 XML、JSON 有更大的優勢2。 Protocol Buffer 的優缺點優點 檔案小、傳輸速度快 適用於多種語言，透過工具可以快速的建立好 Model 前後端使用同一個 proto 檔進行編譯，減少溝通成本 缺點 編譯後的檔案可讀性差 安裝步驟較為繁瑣 Protocol Buffer 的格式Protocol Buffer 的格式大致上長這樣，目前有 proto2 、proto3 兩種版本，但目前以 proto3 居多，也較嚴謹： 123456syntax = &quot;proto3&quot;;message Person { int32 id = 1; string name = 2; string email = 3;} 上方的 id = 1 , name = 2 並不是賦值，而是編號、Key的意思，最後編譯時 Protocol Buffer 才可以依照編號去做比對，並且編號在同一個 Model 內不可以重複，基本上都會從 1 開始依序往下排。另外建議欄位編號介於 1~15 之間，因為在這個範圍會用 1 byte 做編譯，而 16~2047 會用 2 bytes 做編譯，詳情可以看這裡。 安裝本次我們會透過 Homebrew 來安裝 Protobuf ，所以在安裝前我們可以先檢測一下是否已安裝過 Homebrew。 1234# 檢測有無安裝 homebrew$ brew -v# 如果沒有安裝，可以透過以下指令安裝$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 接著安裝 Protobuf Compiler ，整套會需要安裝 automake、libtool、protobuf 。 123$ brew install automake $ brew install libtool $ brew install protobuf 接下來我們要把 Github 上的 protobuf 下載回來，並且執行位於 protobuf/objectivec/DevTool 下的 full_mac_build.sh 執行檔 123$ git clone https://github.com/google/protobuf.git$ cd protobuf/objectivec/DevTools$ ./full_mac_build.sh 建立 proto 檔與編譯STEP 1 第一步我們先建立 proto 檔，副檔名為 .proto，內容的格式如下。 12345678syntax = &quot;proto3&quot;;package package_name;message TradingAccountRequest { string sessionId = 1; string userToken = 2; string language = 3;} 這裡要注意的是 proto 使用的版本，proto2 與 proto3 有滿大的不同，例如 proto3 就移除了 optional 這個關鍵字，並預設所有欄位都是 optional ，如果搞錯了就會出現以下錯誤。 1Explicit 'optional' labels are disallowed in the Proto3 syntax. To define 'optional' fields in Proto3, simply remove the 'optional' label, as fields are 'optional' by default. STEP 2 我們準備好 proto 檔以後，第二步要開始進行編譯。 開啟 src 資料夾建立 protocols 與 gen 資料夾，把 proto 檔放到 protocols 資料夾中。 並開啟 Terminal cd 到 src/ 下使用 protoc ，輸入 proto 檔來源與輸出位置後進行編譯。 12$ cd src$ protoc --proto_path=protocols --objc_out=gen protocols/*.proto 其中的 --proto_path 是 proto 檔的來源資料夾位址，就是剛剛建立的 protocols 資料夾。 而 --objc_out 就是編譯後的 pbobjc.h pbobjc.m 檔案輸出位址，產製好pbobjc.h pbobjc.m 以後，我們將這兩個檔新增至專案中。 STEP 3 最後一步，因為 Protobuf 使用的是 MRC，而現在的專案基本上都是使用 ARC 了，所以我們要去 Build Phase -&gt; Compile Sources，找到我們剛剛新增的pbobjc.m ，並加上 fno-objc-arc 這個Complier Flag。 開始使用經過了這麼多的步驟以後，我們終於可以開始在專案內使用了 🎊。 先在 Xcode 專案中加入 protobuf library，可以使用 Cocoapods 或是直接把檔案下載拉進專案中，但建議使用 Cocoapods 會比較方便。 12# in podfilepod 'Protobuf' 接著一般的 Model 物件一樣使用就可以了。 1234567// 引用#import &quot;Tradingaccount.pbobjc.h&quot;// 使用TradingAccountRequest *request = [TradingAccountRequest new];request.language = @&quot;&quot;;request.sessionId = @&quot;&quot;; 總結Protocol Buffers 帶給開發者另一種資料傳輸的方式，比起常用的 JSON 來說，在效能的優化上是滿明顯的。 但有優點必有缺點，Protocol Buffers 最大的缺點還是不便於直觀的閱讀，所以用起來沒那麼方便。 整體來說要依照開發的情況來去決定要使用哪一個，如果是大量的資訊傳輸，那用 Protocol Buffers 會是一個不錯的選擇。 參考資料Google Protocol buffers Protocol Buffer 入门使用: iOS protobuf3.1.0使用 Protobuf 语法指南","link":"/2021/01/28/iOS-ProtocolBuffers/"},{"title":" Lazy load 延遲載入","text":"以往我們創建變數或物件時，通常會在建立完之後馬上進行初始化，以便後續的程式邏輯運用。那萬一初始化的順序沒有寫好時，很容易遇到使用到尚未初始化的變數，造成程式結果出錯，甚至要花時間去找是哪一個步驟出了問題。 如果使用Lazy load創建物件或變數，就可以有效避免這個問題。 使用 Lazy load 有什麼好處 ?Lazy load 可以讓你可以不必關心變數創建的時機，等到真正使用到變數時才去建立，同時也可以保證在使用時一定是被初始化過的狀態，提高記憶體使用效率。 Objective-C 寫法1234567891011121314151617// in @interface@property (nonatomic, weak) UIButton *registerBtn;// in @implementation- (UIButton*)registerBtn{ if(!_registerBtn) { UIButton *button = [UIButton new]; [button setTitle:@&quot;註冊&quot; forState:UIControlStateNormal]; [button addTarget:self action:@selector(registerBtnClick) forControlEvents:UIControlEventTouchUpInside]; // Save _registerBtn = button; } return _registerBtn;} Objective-C 實作原理、注意事項 透過 Override 物件的 getter 方法，在 getter 方法裡面去判斷物件是否存在。若物件不存在 == nil 時則進行物件的初始化，那如果物件已經存在了，則直接return已經初始化完畢的物件。 所以我們在使用Lazy load的物件時，一定要用 self.變數名稱的方式取值。 Swift 寫法12345678910// 若不進行特殊的初始化，非常簡單，只要前方加上lazy就好lazy var dataSource = UIButton()// 若有要進行初始化或邏輯處理，也不複雜lazy var registerBtn: UIButton = { let button = UIButton() button.setTitle(&quot;註冊&quot;, for: .normal) button.addTarget(self, action: #selector(registerBtnClick), for: .touchUpInside) return button}() Swift 實作原理、注意事項 在 Swift 中 Lazy load 只能用 var 來宣告，因為 let 常數必須在宣告的時候就賦值。 還有一個點要注意，就是在Objective-C中可以將lazy變數設置為nil，就可以再重新初始化。在Swift &amp; Objective-C中的nil代表的是不同的意義，在OC中代表空指針，而在Swift中代表空值，所以在Swift中變數=nil時，就等於直接給他賦值nil，所以使用該變數時也不會像OC一樣再進行一次初始化了。","link":"/2021/01/25/%E3%80%8CiOS%E3%80%8DLazy%20load%20%E5%BB%B6%E9%81%B2%E8%BC%89%E5%85%A5/"}],"tags":[{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Dev","slug":"Dev","link":"/tags/Dev/"}],"categories":[{"name":"程式開發","slug":"程式開發","link":"/categories/%E7%A8%8B%E5%BC%8F%E9%96%8B%E7%99%BC/"},{"name":"iOS","slug":"程式開發/iOS","link":"/categories/%E7%A8%8B%E5%BC%8F%E9%96%8B%E7%99%BC/iOS/"}]}