{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/01/25/hello-world/"},{"title":"","text":"iOS | NSString 要使用 copy 還是 strong 呢？最近在複習 iOS 面試題系列，看到這一題想起幾年前剛接觸 Objective-C ，剛開始觀念還沒有建立起來，也曾經因為這個屬性花了不少時間Debug，雖然現在觀念已經搞懂了，但還是趁這個機會複習筆記一下。 什麼情況下會有差異？你可以先記得，大部分的情況都會使用copy。 而 copy 與 strong 的差別，在於 copy 是儲存「值」，strong 是儲存「記憶體位址」。 舉個例子123// .h file@property (strong,nonatomic) NSString *strongStr;@property (copy, nonatomic) NSString *copyStr; 1234567891011121314151617181920// .m fileNSMutableString *mutableStr = [NSMutableString stringWithFormat:@&quot;abc&quot;];// 將mutableStr賦值給retainStr、copyStrself.strongStr = mutableStr;self.copyStr = mutableStr;// 將 mutableStr 更改為 xyz[mutableStr appendString:@&quot;xyz&quot;];// 印出三個字串的值NSLog(@&quot;mutableStr = %@&quot;,mutableStr);NSLog(@&quot;strongStr = %@&quot;,self.strongStr);NSLog(@&quot;copyStr = %@&quot;,self.copyStr);// 輸出值// mutableStr = xyz// strongStr = xyz// copyStr = abc 可以發現，此時 copy 屬性字串並不會因為賦值來源而更改值，反而是strong屬性的字串隨著來源而改變了。這是因為 copy 屬性是對於來源做了深拷貝，是將 mutableStr 的數值複製到了 copyStr 上；而 strong 屬性是指向來源的記憶體位址，所以當原本的 mutableStr 改變時，strongStr 也會跟著改變。 接著我們在來看一下這三個字串的記憶體位址 123456789// 印出三個字串的記憶體位址mutableStr = abcxyzStrStrong = abcxyzStrCopy = abc// 輸出記憶體位址// mutableStr = 0x6000030ee520// StrStrong = 0x6000030ee520// StrCopy = 0xc09e09c05a166394 這時候我們可以看到 mutableStr 與 StrStrong 的記憶體位址是相同的，代表他們兩個儲存值的地方是一樣的，所以才會造成改變 mutableStr 後 StrStrong 也跟著更改的情況。 小結比較簡單的記憶法就是 NSString 用 Copy 就好，因為實務上也很少會使用 Strong 屬性的情境。雖然現在 Objective-C 比較少人在用了，不過有時候面試還是會考到類似的觀念題，所以邊複習邊整理文章，希望對開發者有些幫助。","link":"/2020/12/28/%E3%80%8CiOS%E3%80%8DNSString%E8%A6%81%E4%BD%BF%E7%94%A8copy%E9%82%84%E6%98%AFstrong%E5%91%A2%EF%BC%9F/"},{"title":"「iOS」Lazy load 延遲載入","text":"以往我們創建變數或物件時，通常會在建立完之後馬上進行初始化，以便後續的程式邏輯運用。那萬一初始化的順序沒有寫好時，很容易遇到使用到尚未初始化的變數，造成程式結果出錯，甚至要花時間去找是哪一個步驟出了問題。 如果使用Lazy load創建物件或變數，就可以有效避免這個問題。 使用 Lazy load 有什麼好處 ?Lazy load 可以讓你可以不必關心變數創建的時機，等到真正使用到變數時才去建立，同時也可以保證在使用時一定是被初始化過的狀態，提高記憶體使用效率。 Objective-C 寫法1234567891011121314151617// in @interface@property (nonatomic, weak) UIButton *registerBtn;// in @implementation- (UIButton*)registerBtn{ if(!_registerBtn) { UIButton *button = [UIButton new]; [button setTitle:@&quot;註冊&quot; forState:UIControlStateNormal]; [button addTarget:self action:@selector(registerBtnClick) forControlEvents:UIControlEventTouchUpInside]; // Save _registerBtn = button; } return _registerBtn;} Objective-C 實作原理、注意事項 透過 Override 物件的 getter 方法，在 getter 方法裡面去判斷物件是否存在。若物件不存在 == nil 時則進行物件的初始化，那如果物件已經存在了，則直接return已經初始化完畢的物件。 所以我們在使用Lazy load的物件時，一定要用 self.變數名稱的方式取值。 Swift 寫法12345678910// 若不進行特殊的初始化，非常簡單，只要前方加上lazy就好lazy var dataSource = UIButton()// 若有要進行初始化或邏輯處理，也不複雜lazy var registerBtn: UIButton = { let button = UIButton() button.setTitle(&quot;註冊&quot;, for: .normal) button.addTarget(self, action: #selector(registerBtnClick), for: .touchUpInside) return button}() Swift 實作原理、注意事項 在 Swift 中 Lazy load 只能用 var 來宣告，因為 let 常數必須在宣告的時候就賦值。 還有一個點要注意，就是在Objective-C中可以將lazy變數設置為nil，就可以再重新初始化。在Swift &amp; Objective-C中的nil代表的是不同的意義，在OC中代表空指針，而在Swift中代表空值，所以在Swift中變數=nil時，就等於直接給他賦值nil，所以使用該變數時也不會像OC一樣再進行一次初始化了。","link":"/2021/01/25/%E3%80%8CiOS%E3%80%8DLazy%20load%20%E5%BB%B6%E9%81%B2%E8%BC%89%E5%85%A5/"},{"title":"","text":"「iOS」Singleton Design Pattern 單例設計模式什麼是Singleton？在許多物件導向設計的程式語言中，單例設計模式非常常見，而他的實際效益就是可以確保在整個應用程式中只會有一個實體，且生命週期也跟應用程式相同，在應用程式啟動時就會自動幫我們建立了。在iOS開發學習的過程中也許你已經用了許多Singleton的物件了，只是你還不知道而已，例如：UIColor、FileManager等等。 Singleton 會用在哪些場合？Singleton因為具有唯一性，所以通常會用於： 環境變數、已定義的參數檔案 常用的資料處理算法，如字串轉換、時間轉換、資料庫連接、網路連接等等。 Singleton 怎麼寫？建立Singleton最基礎的寫法就是判斷實體是不是為空值，如果是空值就會直接建立。在建立時需要注意執行緒衝突，所以我們需要多加上執行緒的安全機制，實際程式碼如下。 123456789// Objective-C 版本+ (instancetype)shareManager{ @synchronized(self){ if (!manager) { manager = [[self alloc]init]; } return manager; }} 也可以透過GCD的方式建立 12345678910111213// Objective-C 版本 , 使用GCDstatic DataManager *manager = nil;@implementation DataManager+ (instancetype)shareManager{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ manager = [[self alloc] init]; }); return manager;}@end 此時Singleton就已經寫好了，只要我們在外面呼叫shareManager這個方法，返回的實體始終是一個，因為dispatch_once只執行一次。 1234// Objective-C 版本 , 呼叫 Singleton{ [DataManager shareManager];}","link":"/2020/11/08/Singleton%20Design%20Pattern%20%E5%96%AE%E4%BE%8B%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"},{"title":"","text":"iOS 資訊安全加固方案 - 程式碼混淆(SwiftShield) 為什麼要做程式碼混淆？最近專案接到需求，為了避免程式被反解譯，也避免程式的核心業務邏輯暴露在外，故開始尋找 App 加固的方案。資訊安全這門領域其實很深，那既然剛入門我們就從基礎的開始，程式碼混淆在資安方案中算是 CP 值比較高的，開發者混淆時付出一些時間(熟悉以後還可以自動化)，但讓駭客就要多付出好幾倍的時間去破解你的程式，所以在基礎的資安加固方案中會比較推薦程式碼混淆。 . 如何做到程式碼混淆？市面上有許多的混淆工具，有收費的也有開源的，如果只是想試點水溫會建議用開源的工具玩玩看。但如果專案有時程壓力，可以試試付費的工具，畢竟省時省力 😂。 這邊我列舉出幾個比較常見的開源混淆工具： (1) 「rockbruno/SwiftShield」: 這是我比較推薦的一個，效能不錯、評價高、重點是還有在維護。 手動模式（Objective-C、Swift）：採後綴混淆，簡單易用，缺點是有特定後綴的才會混淆，不適合已開發的專案。 自動模式（Swift）：全局混淆，也可以指定特定資料夾不混淆，缺點是有些語法混淆後會出錯，需要手動修復或是修改原本的程式寫法，但錯誤通常不多。 (2) 「LennonChin/Code-Confuse-Plugin」: 僅混淆 Objective-C 項目(.h.m)，Swift 需指定忽略。 需求為 Python3，以 Define 定義來替換方法名、類別名。 (3) 「onorZhang/iOSConfuse」: 採用前綴的方式進行混淆，一樣不適合已開發的專案。 使用 SwiftShield 進行程式碼混淆SwiftShield 是一個將 iOS 專案程式碼產製亂數加密名稱的工具，其混淆範圍包含程式碼、Pod 和 Storyboard，可以保護應用程序避免被輕易的反解譯（如 class-dump 和 Cycript）。 混淆後會是什麼樣子？12345class fjiovh4894bvic: XbuinvcxoDHFh3fjid { func cxncjnx8fh83FDJSDd() { return vPAOSNdcbif372hFKF() }} 自動模式（限 Swift 使用）使用-automatic指令，SwiftShield 將使用 SourceKit 自動混淆整個專案，混淆範圍包含程式碼、Pod 和 Storyboard。 注意事項 ⚠️ 目前有一些 SourceKit Bugs 及不會混淆的類型需注意，如果專案中剛好有遇到特定情境可能需要修改程式碼，詳請請參照本連結。 檔案名稱及資料夾名稱不可包含空白，否則執行混淆時會報錯。 檔案名稱及資料夾名稱若有”-“依然會被混淆。 執行步驟 從此處下載最新的 SwiftShield 打開終端機，cd 移動至下載的 Swiftsheild 文件夾下 設置 SwiftShield 的使用權限12345# 給予讀、寫、執行的權限$ sudo chmod -R 777 ./swiftsheild(文件路徑)# 如果使用CocoaPods，需要解鎖權限$ sudo chmod -R 774 [專案路徑] 官方文件有提到，如果有使用到會修改文件的第三方框架，如：R.Swift、SwiftGen，需在專案中的 TARGETS -&gt; Build Phases -&gt; Run Script 修改指令，這裡以 R.Swift 為範例： 1234567# 原本的 Run Script&quot;$PODS_ROOT/R.swift/rswift&quot; generate &quot;$SRCROOT/[專案名稱]&quot;# 修改後的 Run Scriptif [ &quot;$SWIFTSHIELDED&quot; != &quot;true&quot; ]; then &quot;$PODS_ROOT/R.swift/rswift&quot; generate &quot;$SRCROOT/[專案名稱]&quot;fi 準備就緒後就可以來下指令進行混淆了，自動模式的指令有以下幾種 必填參數： -automatic：啟用自動模式。 -project-root：專案項目的根目錄。 SwiftShield 會向下搜索你的項目文件。 -automatic-project-file：專案項目的主要.xcodeproj / .xcworkspace文件。 -automatic-project-scheme [myScheme]：專案項目的Scheme。 *可選參數**： -sdk：防止混淆公共類別和方法。如果你正在構建SDK項目，請使用它。 -ignore-modules：防止混淆某些資料夾，並以逗號分隔。如果無法正確混淆某個資料夾，請使用此選項。 要注意的是，是輸入資料夾的確切名稱，而不是目標名稱。例：MyLib,MyAppRichNotifications,MyAppWatch_Extension -show-sourcekit-queries：打印發送到 SourceKit 的查詢。要注意的是這指令會造成非常龐大的輸出，因此只能將其用於錯誤報告和功能開發！ *實際組出來以後** 12345$ #指令結構$[SwiftShield 路徑]+空白+&quot;swiftshield&quot;+空白+&quot;-automatic&quot;+空白+&quot;-project-root&quot;+空白+&quot;-automatic-project-file&quot;+空白+[xcworkspace 路徑]+空白+&quot;-automatic-project-scheme&quot;+空白+[專案Target]+空白+&quot;-ignore-modules&quot;+空白+[要忽略的項目(含Pods項目，且需以資料夾名稱為主)]$ #實際執行指令$ /Users/mac/swiftshield-3.5.1/bin/swiftshield swiftshield -automatic -project-root /Users/mac/[專案資料夾名稱] -automatic-project-file /Users/mac/[專案名稱].xcworkspace -automatic-project-scheme [專案Target] -ignore-modules Alamofire,MJRefresh,SDWebImage... 指令需要執行一小段時間，過程會看到Building project to gather modules and compiler arguments...、Overwriting、Checking等訊息。 接著直接打開專案執行看看，通常會出現一點混淆錯誤的Error，基本上都是重複的錯誤，這部分跟程式寫法有關。若不想改動原本程式碼，基本上混淆後再逐一修改即可發布。 混淆失敗怎麼辦？編譯過程失敗 檢查所有檔案名稱或資料夾名稱是否有包含空白。 檢查是否給與正確的權限。 打開下載的 swiftshield 執行檔是否有被 MacOS 安全性阻擋。 混淆後專案執行失敗或 Crash 檢查是否有使用到SourceKit Bugs 及不會混淆的類型。 帶 selector 方法的參數中若含有字串，盡量用變量或常量代替1234567// 修改前let item1 = UIBarButtonItem(title: &quot;取消&quot;, style: .plain, target: self, action: #selector(cancelButtonClick(sender:)))//混淆後會​​報錯，混淆後會把）}一起混淆進去，導致項目缺少）}而報錯// 修改後let cencelTitle = &quot;取消&quot;let item1 = UIBarButtonItem(title: cencelTitle, style: .plain, target: self, action: #selector(cancelButtonClick(sender:))) .xib 文件有可能不會連動到混淆後的類別，要修改File's Owner 若錯誤不多可以手動修復，混淆後會產生 swiftshield-output 資料夾，內有conversionMap.txt，可以對應混淆前後的字串。 對加密的 Crash logs 進行反混淆處理成功混淆專案後，SwiftShield 將產生一個輸出文件夾，其中包含一個conversionMap.txt 文件，其中包含對該專案所做的所有更改，讓你查明加密對象的前後的字串。 1234567891011//// SwiftShield// Conversion Map// Automatic mode for MyApp 2.0 153, 2018-09-24 10.23.48//Data:ViewController ===&gt; YytSIcFnBAqTAyRAppDelegate ===&gt; uJXJkhVbwdQGNhhSuperImportantClassThatShouldBeHidden ===&gt; GDqKGsHjJsWQzdq 如果你要對混淆後的程式碼文件進行復原，可以透過以下指令復原 1$ swiftshield -deobfuscate CRASH_FILE -deobfuscate-map PATH_TO_CONVERSION_MAP 總結資訊安全的領域很深，從連線加密、程式碼混淆、LLVM編譯器混淆等等一關接著一關，都是為了保護重要的機密或接口不會被竊取盜用，造成商業損失。其實 iOS 系統已經是相對安全的，但對於通訊、金融行業還是要有一定程度的資安保護，畢竟任何資安加固的措施都不能保證百分之百安全，但透過增加駭客反編譯的難度，就能有效降低駭客破解的速度及讓駭客放棄破解打退堂鼓。 Reference SwiftShield SwiftShield代碼混淆 Swiftshield：SwiftOBJ-C 代碼混淆工具 另外我在搜尋資料時也意外發現有幾篇文章不錯，也分享跟大家。 資訊安全從連線加密入手","link":"/2020/04/10/iOS%20%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA%E6%96%B9%E6%A1%88-%E7%A8%8B%E5%BC%8F%E7%A2%BC%E6%B7%B7%E6%B7%86(SwiftShield)/"},{"title":"","text":"如何有效地清理 Xcode大家都知道 Xcode 除了是吃效能的怪獸以外，同時也是很會吃儲存空間的開發工具。 若一開始再購買 mac 時沒有把硬碟空間買好買滿，那未來在開發時很有可能會遇到空間不足的問題。尤其是在 Xcode 改版時，如果要同時兼容新舊版本，那就會是一件非常痛苦的事。 以下一些清空間的方法，希望可以幫助到還在苦海的各位 (我也曾經在那片海裡QQ)。 1. Build App caches用途： 儲存各App Build的結果，並生成索引位置： ~/Library/Developer/Xcode/DerivedData刪除方法： 直接刪除 DerivedData 內所有檔案即可備註： 對於 DerivedData 有興趣的可以看這裡 2. iOS DeviceSupport用途： 儲存 iOS 的版本位置： ~/Library/Developer/Xcode/iOS DeviceSupport刪除方法： 直接刪除iOS版本即可，如14.2 (18B92)備註： 以實機開發時，每一台設備的版本被都會儲存起來，如果你用許多不同的iOS的版本在測試，那使用空間就會很可觀 3. Simulator devices用途： 模擬器版本位置： ~/Library/Developer/CoreSimulator/Devices刪除方法： 至終端機下指令xcrun simctl delete unavailable 4. Archives &amp; .ipa file用途： 每次打包專案時都會產生，用來提交 App Store 或是TestFlight 等等位置： ~/Library/Developer/Xcode/Archives刪除方法： 直接刪除即可備註： 若為已上線之產品，建議預留最後3-5個的版本 5. Logs用途： 就，Log位置： ~/Library/Developer/Xcode/iOS Device Logs刪除方法： 直接刪除 iOS Device Logs 內所有檔案即可 6. Others cache用途： 整個資源庫的快取位置： ~/Library/Caches/刪除方法： 直接刪除 Caches 內所有檔案即可備註： 若不放心，可以將資料夾移到桌面，再重啟電腦看有沒有異狀。 工具推薦：App DevCleaner for Xcode 非常實用的工具，可以快速清除 DeviceSupport、DerivedData、Archives 等等快取檔案。詳細的使用方法可以參考彼得潘的教學 總結：雖然這些肥大的檔案總是讓我們恨得牙癢癢，但不得不說這些檔案確實在編譯階段幫我們省下了不少時間，也是一種用空間換時間的概念。 剛好遇到問題所以隨筆記錄一下，同時希望這些方法也有幫助到你。","link":"/2020/12/02/%E3%80%8CiOS%E3%80%8D%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E5%9C%B0%E6%B8%85%E7%90%86Xcode/"},{"title":"","text":"Swift | GCD 多執行緒多執行緒一直是日常開發中很常使用的部分，尤其是在網路連接的使用更是頻繁，而多執行緒有GCD、NSOperation、NSThread等等，本次的介紹就從GCD開始。 GCD 是什麼？Grand Central Dispatch（GCD）是Apple官方推薦的多執行緒解決方案，比起其他的方式來說，多了不少的優勢： GCD使用CPU資源的效率比較高。 開發者不用去管理執行緒的生命週期。 開發者只要告訴GCD要執行什麼任務，不用去額外多寫程式碼。 同步與異步CGD中的任務區分為同步與異步兩種執行方式，兩者的區別在於是否等待其他隊列執行結束，以及是否可以直接開啟新的執行緒去執行任務。 同步執行(sync)：新增任務到同步列隊中，在其他任務執行完畢之前，任務都會一直處於等待的狀態。異步執行（async）：新增任務到異步列隊中，不用等待其他的任務結束，一新增馬上就可以執行，且具備開啟新的執行緒的能力。 主要在於有順序性的排隊執行，或是開啟新執行緒並同時執行。","link":"/2020/11/08/Swift-GCD%20%E5%A4%9A%E5%9F%B7%E8%A1%8C%E7%B7%92/"},{"title":"","text":"iOS | Unable to simultaneously satisfy constraints 約束設定錯誤處理在iOS開發中，幾乎所有頁面都會使用Autolayout的方式去排版，而在設定完LayoutConstraints後，有時會在Runtime出現一些Error log，雖然不一定會影響顯示出來的排版，但有報錯基本上就要修正。 Error Log12345678910111213141516[LayoutConstraints] Unable to simultaneously satisfy constraints. Probably at least one of the constraints in the following list is one you don't want. Try this: (1) look at each constraint and try to figure out which you don't expect; (2) find the code that added the unwanted constraint or constraints and fix it. ( &quot;&lt;MASLayoutConstraint:0x600000393660 UIButton:0x7fe97b466f20.right == UIView:0x7fe97b458ba0.right - 20&gt;&quot;, &quot;&lt;NSLayoutConstraint:0x6000004f1a90 UIImageView:0x7fe97b4671d0.leading == UIButton:0x7fe97b466f20.trailing + 8&gt;&quot;, &quot;&lt;NSLayoutConstraint:0x6000004f1540 UIView:0x7fe97b458ba0.trailing == UIImageView:0x7fe97b4671d0.trailing + 20&gt;&quot;)Will attempt to recover by breaking constraint &lt;NSLayoutConstraint:0x600001baebc0 UIImageView:0x7fe97b4671d0.leading == UIButton:0x7fe97b466f20.trailing + 8&gt;Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKitCore/UIView.h&gt; may also be helpful. 什麼情況會出現這個錯誤？一般來說，出現這種警告有兩種情況： 使用xib的內建View，對其中子元件增加了Autolayout約束，在使用xib後又調整了View的框架 純Code的方式使用Autolayout，但沒有對使用的ViewAutoresizingMaskIntoConstraints的屬性設置為false。 如何快速找出有問題的元件？其實在Error log中有給出很明錯錯誤的地方，那就是在log中Will attempt to recover by breaking constraint的下一行，就是我們要尋找的約束。 123// 關鍵線索Will attempt to recover by breaking constraint &lt;NSLayoutConstraint:0x600001baebc0 UIImageView:0x7fe97b4671d0.leading == UIButton:0x7fe97b466f20.trailing + 8&gt; 但初學者在看到這個錯誤時會特別的頭痛，因為在Error log中通常只會寫出哪個元件的類型，例如：NSLayoutConstraint、UIImageView等等，這樣對於比較複雜的頁面會很難找出錯誤的約束。 Xcode其實提供了一個很方便的Debug功能，可以幫助我們迅速地找到錯誤的約束，而我們要使用的就是Xcode內建的Debug View Hierarchy。 使用Debug View Hierarchy找出元件STEP 1： 執行AppSTEP 2： 點選 Xcode 下方的 Debug View Hierarchy 這時候你會看到整個App所有View的結構，是不是很方便呢 STEP 3： 找出錯誤約束的實體位址還記得剛剛我們有特別找出錯誤的約束嗎？ 1234Will attempt to recover by breaking constraint // 我們要的就是NSLayoutConstraint的實體位址0x600001baebc0&lt;NSLayoutConstraint:0x600001baebc0 UIImageView:0x7fe97b4671d0.leading == UIButton:0x7fe97b466f20.trailing + 8&gt; 而我們要找的就是第3行的部分，將NSLayoutConstraint的實體位址0x600001baebc0複製起來。 STEP 4： 用實體位址去找出錯誤的約束在哪裡接著我們去左邊Debug navigator搜尋，並以剛剛的0x600001baebc0過濾元件，這時候就可以很快速的找到出錯的約束了。 總結以前在初學的時候，遇到這個問題總是很頭痛，有一種大海撈針的感覺。而現在透過Xcdoe內建的Debug View Hierarchy就可以很快速的找到特定的元件，有時也可以查看UI元件的排版是不是有誤，真的是很方便很多。","link":"/2020/12/02/Unable%20to%20simultaneously%20satisfy%20constraints%20%E7%B4%84%E6%9D%9F%E8%A8%AD%E5%AE%9A%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86/"},{"title":"My New Post","text":"","link":"/2021/01/25/My-New-Post/"}],"tags":[{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"iOS, 資訊安全, 混淆","slug":"iOS-資訊安全-混淆","link":"/tags/iOS-%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8-%E6%B7%B7%E6%B7%86/"},{"name":"iOS , Xcode , IDE","slug":"iOS-Xcode-IDE","link":"/tags/iOS-Xcode-IDE/"}],"categories":[]}